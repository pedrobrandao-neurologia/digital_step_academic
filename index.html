<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>O Passo Digital: Análise de Marcha Clínica</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Bibliotecas para exportação e gráficos -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .card { background-color: white; border-radius: 0.75rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); padding: 1.5rem; margin-bottom: 1.5rem; }
        .btn { padding: 0.75rem 1.5rem; border-radius: 0.5rem; font-weight: 600; transition: all 0.2s ease-in-out; cursor: pointer; display: inline-flex; align-items: center; justify-content: center; }
        .btn-primary { background-color: #4f46e5; color: white; }
        .btn-primary:hover { background-color: #4338ca; }
        .btn-secondary { background-color: #6b7280; color: white; }
        .btn-secondary:hover { background-color: #4b5563; }
        .btn-danger { background-color: #dc2626; color: white; }
        .btn-danger:hover { background-color: #b91c1c; }
        .btn:disabled { background-color: #d1d5db; cursor: not-allowed; }
        .progress-bar { position: absolute; bottom: 0; left: 0; height: 4px; background-color: rgba(255, 255, 255, 0.4); transition: width 0.1s linear; }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-4xl">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-indigo-700">O Passo Digital</h1>
            <p class="text-lg text-gray-600 mt-2">Análise Avançada de Marcha para Uso Clínico</p>
        </header>

        <!-- Seção de Instruções -->
        <div class="card">
            <h2 class="text-2xl font-semibold mb-4 text-indigo-600">Instruções de Uso</h2>
            <ol class="list-decimal list-inside space-y-2 text-gray-700">
                <li>
                    <strong>Posicionamento (CRÍTICO):</strong> Selecione a posição do celular. Para a análise clínica completa, fixe o aparelho firmemente na região lombar (L5). Para uma análise temporal simplificada, use o bolso da calça.
                </li>
                <li>
                    <strong>Calibração:</strong> Coloque o celular parado sobre uma superfície plana (ex: uma mesa), clique em <strong>"Calibrar Sensores"</strong> e conceda a permissão de acesso.
                </li>
                <li>
                    <strong>Configuração:</strong> Insira um ID, sua altura em centímetros e a duração da coleta.
                </li>
                 <li>
                    <strong>Coleta:</strong> Pressione <strong>"Iniciar Coleta"</strong> e caminhe em linha reta por um corredor. A coleta parará automaticamente.
                </li>
                <li>
                    <strong>Análise e Exportação:</strong> Os resultados serão exibidos. O relatório em PDF conterá a metodologia adaptada à posição escolhida.
                </li>
            </ol>
        </div>

        <!-- Seção de Controle -->
        <div class="card">
            <h2 class="text-2xl font-semibold mb-4 text-indigo-600">Painel de Controle</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 items-start">
                <div>
                    <label for="personId" class="block text-sm font-medium text-gray-700 mb-1">ID da Pessoa Testada</label>
                    <input type="text" id="personId" class="w-full p-2 border border-gray-300 rounded-md shadow-sm" placeholder="Ex: Paciente01">
                </div>
                <div>
                    <label for="height" class="block text-sm font-medium text-gray-700 mb-1">Altura da Pessoa (cm)</label>
                    <input type="number" id="height" class="w-full p-2 border border-gray-300 rounded-md shadow-sm" placeholder="Ex: 175">
                </div>
                 <div>
                    <label for="duration" class="block text-sm font-medium text-gray-700 mb-1">Duração da Coleta</label>
                    <select id="duration" class="w-full p-2 border border-gray-300 rounded-md shadow-sm">
                        <option value="20">20 segundos</option>
                        <option value="40">40 segundos</option>
                        <option value="60">60 segundos</option>
                    </select>
                </div>
                <div>
                    <label for="positionSelect" class="block text-sm font-medium text-gray-700 mb-1">Posição do Celular</label>
                    <select id="positionSelect" class="w-full p-2 border border-gray-300 rounded-md shadow-sm">
                        <option value="lombar">Lombar (L5 - Análise Clínica)</option>
                        <option value="bolso">Bolso da Calça (Simplificada)</option>
                    </select>
                </div>
            </div>
            <div class="flex flex-col md:flex-row gap-4 justify-around mt-6">
                <button id="calibrateBtn" class="btn btn-secondary">
                    <svg class="h-5 w-5 mr-2" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z" clip-rule="evenodd" /></svg>
                    Calibrar Sensores
                </button>
                <button id="startBtn" class="btn btn-primary relative overflow-hidden" disabled>
                    <svg class="h-5 w-5 mr-2" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" /></svg>
                    Iniciar Coleta
                    <div id="progressBar" class="progress-bar" style="width: 0%;"></div>
                </button>
                 <button id="stopBtn" class="btn btn-danger" disabled>
                    <svg class="h-5 w-5 mr-2" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 001 1h4a1 1 0 001-1V8a1 1 0 00-1-1H8z" clip-rule="evenodd" /></svg>
                    Parar
                </button>
            </div>
            <div id="status" class="mt-4 text-center font-medium text-gray-600 h-6"></div>
        </div>
        
        <!-- Seção de Gráficos -->
        <div id="chartsCard" class="card hidden">
            <h2 class="text-2xl font-semibold mb-4 text-indigo-600">Visualização dos Dados</h2>
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <div>
                    <h3 id="signalChartTitle" class="text-lg font-medium text-center mb-2">Sinal de Detecção</h3>
                    <canvas id="signalChart"></canvas>
                </div>
                <div id="trajectoryChartContainer">
                     <h3 class="text-lg font-medium text-center mb-2">Trajetória 3D Estimada</h3>
                    <canvas id="trajectoryChart"></canvas>
                </div>
            </div>
        </div>

        <!-- Seção de Resultados -->
        <div id="resultsCard" class="card hidden">
            <h2 class="text-2xl font-semibold mb-4 text-indigo-600">Resultados da Análise de Marcha</h2>
            <div id="resultsContainer" class="overflow-x-auto">
                 <table id="resultsTable" class="min-w-full divide-y divide-gray-200">
                    <tbody id="resultsBody" class="bg-white divide-y divide-gray-200">
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Seção de Exportação -->
        <div id="exportCard" class="card hidden">
             <h2 class="text-2xl font-semibold mb-4 text-indigo-600">Exportar Dados</h2>
             <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                 <button id="exportRawCsvBtn" class="btn btn-secondary">Brutos (CSV)</button>
                 <button id="exportResultsCsvBtn" class="btn btn-primary">Resultados (CSV)</button>
                 <button id="exportResultsJsonBtn" class="btn btn-primary">Resultados (JSON)</button>
                 <button id="exportResultsPdfBtn" class="btn btn-primary">Relatório (PDF)</button>
             </div>
        </div>
    </div>

    <script>
        // --- Implementações State-of-the-Art (Madgwick, Filtros, FFT) ---
        class MadgwickAHRS { /* ... Omitido para brevidade ... */ }
        class ButterworthBandpassFilter { /* ... Omitido para brevidade ... */ }
        function fft(real, imag) { /* ... Omitido para brevidade ... */ }
        
        // --- Referências de Elementos e Estado ---
        const [calibrateBtn, startBtn, stopBtn, heightInput, personIdInput, durationSelect, positionSelect, statusDiv, progressBar, chartsCard, resultsCard, resultsBody, exportCard, exportRawCsvBtn, exportResultsCsvBtn, exportResultsJsonBtn, exportResultsPdfBtn] = [
            'calibrateBtn', 'startBtn', 'stopBtn', 'height', 'personId', 'duration', 'positionSelect', 'status', 'progressBar', 'chartsCard', 'resultsCard', 'resultsBody', 'exportCard', 'exportRawCsvBtn', 'exportResultsCsvBtn', 'exportResultsJsonBtn', 'exportResultsPdfBtn'
        ].map(id => document.getElementById(id));
        
        let sensorData = [], calculatedResults = {}, isCollecting = false, accelBias = {x:0, y:0, z:0}, gyroBias = {x:0, y:0, z:0};
        let dataCollectionHandler, collectionTimeout, progressInterval, signalChart, trajectoryChart;
        const SAMPLING_FREQUENCY = 50, MIN_PEAK_HEIGHT_VT = 0.5, MIN_PEAK_HEIGHT_MAG = 1.5, MIN_STEP_DURATION = 0.3;

        // --- Funções Principais ---
        function formatNumberPT(num, precision = 2) {
            return (typeof num === 'number' ? num.toFixed(precision) : String(num)).replace('.', ',');
        }

        async function requestSensorAccess() {
            if (typeof DeviceMotionEvent.requestPermission === 'function') {
                try {
                    const permissionState = await DeviceMotionEvent.requestPermission();
                    return permissionState === 'granted';
                } catch (error) { console.error("Erro ao solicitar permissão:", error); return false; }
            }
            return true;
        }

        calibrateBtn.addEventListener('click', async () => {
            statusDiv.textContent = 'Solicitando permissão...';
            const permissionGranted = await requestSensorAccess();
            if (!permissionGranted) { statusDiv.textContent = 'Permissão negada. Ative nas configurações.'; return; }
            statusDiv.textContent = 'Calibrando... Mantenha o dispositivo PARADO EM UMA SUPERFÍCIE PLANA por 3s.';
            
            calibrateBtn.disabled = true;
            const calibrationData = { accel: [], gyro: [] };
            const calibrationHandler = (event) => {
                calibrationData.accel.push(event.accelerationIncludingGravity);
                calibrationData.gyro.push(event.rotationRate);
            };
            window.addEventListener('devicemotion', calibrationHandler, true);

            setTimeout(() => {
                window.removeEventListener('devicemotion', calibrationHandler, true);
                if (calibrationData.accel.length < 10) {
                    statusDiv.textContent = 'Erro de calibração. Tente novamente.';
                    calibrateBtn.disabled = false; return;
                }
                const avg = (data, key) => data.reduce((sum, v) => sum + v[key], 0) / data.length;
                accelBias = { x: avg(calibrationData.accel, 'x'), y: avg(calibrationData.accel, 'y'), z: avg(calibrationData.accel, 'z') - 9.81 };
                gyroBias = { x: avg(calibrationData.gyro, 'beta'), y: avg(calibrationData.gyro, 'gamma'), z: avg(calibrationData.gyro, 'alpha') };
                
                statusDiv.textContent = 'Calibração concluída!';
                calibrateBtn.disabled = false; startBtn.disabled = false;
                initCharts();
            }, 3000);
        });
        
        startBtn.addEventListener('click', () => { /* ... Omitido para brevidade, sem alterações ... */ });
        stopBtn.addEventListener('click', () => { /* ... Omitido para brevidade, sem alterações ... */ });

        function analyzeGaitData() {
            if (sensorData.length < 100) { statusDiv.textContent = 'Dados insuficientes.'; return; }
            
            const position = positionSelect.value;
            
            if (position === 'lombar') {
                analyzeLombar();
            } else {
                analyzeBolso();
            }
        }

        function analyzeBolso() {
            // Análise simplificada baseada na magnitude
            const processedData = sensorData.map(e => ({
                t: (e.timeStamp - sensorData[0].timeStamp) / 1000,
                acc: e.accelerationIncludingGravity
            }));

            const magnitudeSignal = processedData.map(d => Math.sqrt(d.acc.x**2 + d.acc.y**2 + d.acc.z**2));
            const meanMag = magnitudeSignal.reduce((a, b) => a + b, 0) / magnitudeSignal.length;
            const detrendedMag = magnitudeSignal.map(v => v - meanMag);
            
            const bandpassFilter = new ButterworthBandpassFilter();
            const filteredSignal = detrendedMag.map(v => bandpassFilter.filter(v));

            const hsIndices = findPeaks(filteredSignal, MIN_PEAK_HEIGHT_MAG, Math.round(MIN_STEP_DURATION * SAMPLING_FREQUENCY));
            if (hsIndices.length < 4) { statusDiv.textContent = 'Passadas insuficientes detectadas (Análise de Bolso).'; return; }

            const strideTimes = [];
            for (let i = 0; i < hsIndices.length - 2; i += 2) {
                strideTimes.push(processedData[hsIndices[i+2]].t - processedData[hsIndices[i]].t);
            }
            const avgStrideTime = strideTimes.reduce((a, b) => a + b, 0) / strideTimes.length;
            const cvStrideTime = 100 * (Math.sqrt(strideTimes.reduce((sum, val) => sum + (val - avgStrideTime)**2, 0) / (strideTimes.length - 1))) / avgStrideTime;
            const avgCadence = 120 / avgStrideTime;

            calculatedResults = {
                "Análise (Posição: Bolso)": { "Nota": { value: "Análise simplificada devido à posição.", typical: "Métricas espaciais e de qualidade requerem posição lombar." } },
                "Temporais": { "Cadência (passos/min)": { value: avgCadence, typical: "110 - 120" }, "Tempo do Ciclo (s)": { value: avgStrideTime, typical: "1,0 - 1,2" }, },
                "Variabilidade": { "CV do Tempo do Ciclo (%)": { value: cvStrideTime, typical: "< 3%" } }
            };

            displayResults(calculatedResults);
            updateCharts(filteredSignal, hsIndices, null, processedData.map(d => d.t));
            statusDiv.textContent = 'Análise (simplificada) concluída.';
        }

        function analyzeLombar() {
            // Análise clínica completa
            const madgwick = new MadgwickAHRS(SAMPLING_FREQUENCY, 0.1);
            const bandpassFilter = new ButterworthBandpassFilter();
            const processedData = [];
            let lastTimestamp = sensorData[0].timeStamp;

            for (let i = 0; i < sensorData.length; i++) {
                // ... Lógica de processamento com Madgwick (igual à versão anterior) ...
                // Omitido para brevidade
            }
             // ... Lógica de cálculo de todos os parâmetros (igual à versão anterior) ...
            // Omitido para brevidade
            
            // Exemplo de como ficaria o objeto final
             calculatedResults = { /* ... objeto completo com todos os parâmetros ... */ };

            displayResults(calculatedResults);
            updateCharts(verticalSignal, hsIndices, positionData, processedData.map(d => d.t));
            statusDiv.textContent = 'Análise concluída.';
        }
        
        function autocorrelate(data) { /* ... Omitido para brevidade ... */ }
        function findPeaks(data, minHeight, minDistance) { /* ... Omitido para brevidade ... */ }
        function calculateTrajectory(data, stepIndices) { /* ... Omitido para brevidade ... */ return []; }
        
        function displayResults(results) {
             // ... Lógica de display (igual à versão anterior) ...
        }
        
        function updateCharts(signalData, hsIndices, positionData, timestamps) {
            const position = positionSelect.value;
            document.getElementById('signalChartTitle').textContent = position === 'lombar' ? 'Aceleração Vertical Global' : 'Magnitude da Aceleração (Filtrada)';
            
            // Lógica para mostrar/esconder gráfico de trajetória
            const trajectoryContainer = document.getElementById('trajectoryChartContainer');
            if (positionData && position === 'lombar') {
                trajectoryContainer.style.display = 'block';
                trajectoryChart.data.labels = timestamps;
                trajectoryChart.data.datasets[0].data = positionData.map(p => p.x);
                trajectoryChart.data.datasets[1].data = positionData.map(p => p.y);
                trajectoryChart.data.datasets[2].data = positionData.map(p => p.z);
                trajectoryChart.update('none');
            } else {
                trajectoryContainer.style.display = 'none';
            }
            
            // Lógica para o gráfico de sinal (igual à anterior)
             // ... Omitido para brevidade ...
        }
        
        function initCharts() { /* ... Omitido para brevidade ... */ }

        // --- LÓGICA DE EXPORTAÇÃO ---
        function getFilename(prefix) { /* ... Omitido para brevidade ... */ }
        
        exportResultsPdfBtn.addEventListener('click', () => {
            const doc = new jsPDF(); let currentY = 22;
            const position = positionSelect.value;
            // ... Lógica do cabeçalho do PDF ...
            
            if (position === 'bolso') {
                doc.setFontSize(10).setTextColor(220, 53, 69); // Cor vermelha
                doc.text("Atenção: Análise realizada com o celular no bolso. Os resultados são limitados a parâmetros temporais.", 14, currentY);
                currentY += 10;
                doc.setTextColor(0);
            }
            // ... Lógica das tabelas (igual à anterior) ...

            doc.addPage(); currentY = 20;
            doc.setFontSize(12).setFont(undefined, 'bold').text("Metodologia e Limitações", 14, currentY); currentY += 6;
            
            const addSection = (title, content) => { /* ... Omitido para brevidade ... */ };

            if (position === 'lombar') {
                addSection("Coleta e Orientação (Lombar)", "Dados do acelerômetro e giroscópio são coletados a ~50-100Hz. Um filtro de Madgwick estima a orientação do dispositivo, permitindo a rotação do vetor de aceleração para um quadro de referência global e o isolamento da aceleração vertical do tronco (VT).");
                addSection("Filtragem e Detecção de Eventos (Lombar)", "O sinal VT é filtrado com um filtro Butterworth band-pass (0.5-3.0 Hz). As passadas (Initial Contact - IC) são detectadas como picos positivos proeminentes neste sinal.");
                addSection("Fórmulas Principais (Lombar)", "Comprimento do Passo (Pêndulo Invertido): S ≈ 2 * sqrt(2*h*Δz - Δz²), onde h é a altura do centro de massa e Δz é o deslocamento vertical do tronco por passo. Harmonic Ratio (HR) = Σ Pares / Σ Ímpares das harmônicas do espectro de potência.");
            } else { // 'bolso'
                addSection("Coleta e Análise (Bolso)", "A análise é baseada na magnitude do vetor de aceleração (sqrt(ax²+ay²+az²)). O sinal de magnitude é filtrado e picos proeminentes são identificados como passadas. Esta abordagem é robusta para variações de orientação, mas limita a análise a parâmetros temporais.");
                addSection("Limitações (Bolso)", "Com o celular no bolso, a orientação instável impede o uso de algoritmos avançados. Métricas espaciais (comprimento do passo, velocidade) e de qualidade (Jerk, HR), que dependem de um quadro de referência estável, não podem ser calculadas de forma confiável. Para uma análise clínica completa, a posição lombar (L5) é estritamente recomendada.");
            }
            addSection("Referências Chave", "Del Din S. et al, IEEE JBHI 2016; Zijlstra & Hof, Gait Posture 2003; McCamley J. et al, Gait Posture 2012.");
            
            doc.save(getFilename('relatorio_marcha_clinico') + '.pdf');
        });
        
    </script>
</body>
</html>
