<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>O Passo Digital: Análise de Marcha Clínica</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Bibliotecas para exportação e gráficos -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .card { background-color: white; border-radius: 0.75rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); padding: 1.5rem; margin-bottom: 1.5rem; }
        .btn { padding: 0.75rem 1.5rem; border-radius: 0.5rem; font-weight: 600; transition: all 0.2s ease-in-out; cursor: pointer; display: inline-flex; align-items: center; justify-content: center; }
        .btn-primary { background-color: #4f46e5; color: white; }
        .btn-primary:hover { background-color: #4338ca; }
        .btn-secondary { background-color: #6b7280; color: white; }
        .btn-secondary:hover { background-color: #4b5563; }
        .btn-danger { background-color: #dc2626; color: white; }
        .btn-danger:hover { background-color: #b91c1c; }
        .btn:disabled { background-color: #d1d5db; cursor: not-allowed; }
        .progress-bar { position: absolute; bottom: 0; left: 0; height: 4px; background-color: rgba(255, 255, 255, 0.4); transition: width 0.1s linear; }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-4xl">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-indigo-700">O Passo Digital</h1>
            <p class="text-lg text-gray-600 mt-2">Análise Avançada de Marcha para Uso Clínico</p>
        </header>

        <!-- Seção de Instruções -->
        <div class="card">
            <h2 class="text-2xl font-semibold mb-4 text-indigo-600">Instruções de Uso</h2>
            <ol class="list-decimal list-inside space-y-2 text-gray-700">
                <li>
                    <strong>Posicionamento (CRÍTICO):</strong> Fixe o celular firmemente na região lombar (sobre a vértebra L5, acima dos glúteos), com um cinto ou suporte apropriado. Esta posição é essencial para a validade dos cálculos.
                </li>
                <li>
                    <strong>Calibração:</strong> Com o celular já posicionado, fique parado em pé por 3 segundos e clique em <strong>"Calibrar Sensores"</strong>. Conceda a permissão de acesso aos sensores.
                </li>
                <li>
                    <strong>Configuração:</strong> Insira um ID, sua altura em centímetros e a duração da coleta.
                </li>
                 <li>
                    <strong>Coleta:</strong> Pressione <strong>"Iniciar Coleta"</strong> e caminhe em linha reta por um corredor. A coleta parará automaticamente.
                </li>
                <li>
                    <strong>Análise e Exportação:</strong> Os resultados e gráficos serão exibidos. O relatório em PDF contém a metodologia detalhada.
                </li>
            </ol>
        </div>

        <!-- Seção de Controle -->
        <div class="card">
            <h2 class="text-2xl font-semibold mb-4 text-indigo-600">Painel de Controle</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 items-start">
                <div>
                    <label for="personId" class="block text-sm font-medium text-gray-700 mb-1">ID da Pessoa Testada</label>
                    <input type="text" id="personId" class="w-full p-2 border border-gray-300 rounded-md shadow-sm" placeholder="Ex: Paciente01">
                </div>
                <div>
                    <label for="height" class="block text-sm font-medium text-gray-700 mb-1">Altura da Pessoa (cm)</label>
                    <input type="number" id="height" class="w-full p-2 border border-gray-300 rounded-md shadow-sm" placeholder="Ex: 175">
                </div>
                 <div>
                    <label for="duration" class="block text-sm font-medium text-gray-700 mb-1">Duração da Coleta</label>
                    <select id="duration" class="w-full p-2 border border-gray-300 rounded-md shadow-sm">
                        <option value="20">20 segundos</option>
                        <option value="40">40 segundos</option>
                        <option value="60">60 segundos</option>
                    </select>
                </div>
                <div class="hidden"> <!-- Ocultado, pois a análise agora é padronizada no eixo vertical global -->
                    <label for="axis" class="block text-sm font-medium text-gray-700 mb-1">Eixo de Análise</label>
                    <select id="axis" class="w-full p-2 border border-gray-300 rounded-md shadow-sm">
                        <option value="vertical_world">Vertical Global (Recomendado)</option>
                    </select>
                </div>
            </div>
            <div class="flex flex-col md:flex-row gap-4 justify-around mt-6">
                <button id="calibrateBtn" class="btn btn-secondary">
                    <svg class="h-5 w-5 mr-2" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z" clip-rule="evenodd" /></svg>
                    Calibrar Sensores
                </button>
                <button id="startBtn" class="btn btn-primary relative overflow-hidden" disabled>
                    <svg class="h-5 w-5 mr-2" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" /></svg>
                    Iniciar Coleta
                    <div id="progressBar" class="progress-bar" style="width: 0%;"></div>
                </button>
                 <button id="stopBtn" class="btn btn-danger" disabled>
                    <svg class="h-5 w-5 mr-2" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 001 1h4a1 1 0 001-1V8a1 1 0 00-1-1H8z" clip-rule="evenodd" /></svg>
                    Parar
                </button>
            </div>
            <div id="status" class="mt-4 text-center font-medium text-gray-600 h-6"></div>
        </div>
        
        <!-- Seção de Gráficos -->
        <div id="chartsCard" class="card hidden">
            <h2 class="text-2xl font-semibold mb-4 text-indigo-600">Visualização dos Dados</h2>
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <div>
                    <h3 class="text-lg font-medium text-center mb-2">Aceleração Vertical Global</h3>
                    <canvas id="signalChart"></canvas>
                </div>
                <div>
                     <h3 class="text-lg font-medium text-center mb-2">Trajetória 3D Estimada</h3>
                    <canvas id="trajectoryChart"></canvas>
                </div>
            </div>
        </div>

        <!-- Seção de Resultados -->
        <div id="resultsCard" class="card hidden">
            <h2 class="text-2xl font-semibold mb-4 text-indigo-600">Resultados da Análise de Marcha</h2>
            <div id="resultsContainer" class="overflow-x-auto">
                 <table id="resultsTable" class="min-w-full divide-y divide-gray-200">
                    <tbody id="resultsBody" class="bg-white divide-y divide-gray-200">
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Seção de Exportação -->
        <div id="exportCard" class="card hidden">
             <h2 class="text-2xl font-semibold mb-4 text-indigo-600">Exportar Dados</h2>
             <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                 <button id="exportRawCsvBtn" class="btn btn-secondary">Brutos (CSV)</button>
                 <button id="exportResultsCsvBtn" class="btn btn-primary">Resultados (CSV)</button>
                 <button id="exportResultsJsonBtn" class="btn btn-primary">Resultados (JSON)</button>
                 <button id="exportResultsPdfBtn" class="btn btn-primary">Relatório (PDF)</button>
             </div>
        </div>
    </div>

    <script>
        // --- Implementações State-of-the-Art (Madgwick, Filtros, FFT) ---
        
        // MadgwickAHRS: Estima a orientação do dispositivo usando acelerômetro e giroscópio.
        class MadgwickAHRS {
            constructor(sampleFreq, beta) {
                this.sampleFreq = sampleFreq;
                this.beta = beta;
                this.q = [1, 0, 0, 0]; // Quaternion [w, x, y, z]
            }

            update(gx, gy, gz, ax, ay, az, dt) {
                let [q0, q1, q2, q3] = this.q;
                
                // Normaliza a aceleração
                let recipNorm = Math.sqrt(ax * ax + ay * ay + az * az);
                if (recipNorm > 0) {
                    recipNorm = 1 / recipNorm;
                    ax *= recipNorm; ay *= recipNorm; az *= recipNorm;
                } else { return; }

                // Gradiente descendente
                const _2q0 = 2 * q0, _2q1 = 2 * q1, _2q2 = 2 * q2, _2q3 = 2 * q3;
                const _4q0 = 4 * q0, _4q1 = 4 * q1, _4q2 = 4 * q2;
                const _8q1 = 8 * q1, _8q2 = 8 * q2;
                const q0q0 = q0 * q0, q1q1 = q1 * q1, q2q2 = q2 * q2, q3q3 = q3 * q3;

                let s0 = _4q0 * q2q2 + _2q2 * ax + _4q0 * q1q1 - _2q1 * ay;
                let s1 = _4q1 * q3q3 - _2q3 * ax + 4 * q0q0 * q1 + _2q0 * ay - _4q1 + _8q1 * q1q1 + _8q1 * q2q2 + _4q1 * az;
                let s2 = 4 * q0q0 * q2 + _2q0 * ax + _4q2 * q3q3 - _2q3 * ay - _4q2 + _8q2 * q1q1 + _8q2 * q2q2 + _4q2 * az;
                let s3 = 4 * q1q1 * q3 - _2q1 * ax + 4 * q2q2 * q3 - _2q2 * ay;

                recipNorm = 1 / Math.sqrt(s0 * s0 + s1 * s1 + s2 * s2 + s3 * s3);
                s0 *= recipNorm; s1 *= recipNorm; s2 *= recipNorm; s3 *= recipNorm;

                // Aplica o feedback
                const qDot0 = 0.5 * (-q1 * gx - q2 * gy - q3 * gz);
                const qDot1 = 0.5 * (q0 * gx + q2 * gz - q3 * gy);
                const qDot2 = 0.5 * (q0 * gy - q1 * gz + q3 * gx);
                const qDot3 = 0.5 * (q0 * gz + q1 * gy - q2 * gx);
                
                const rate = this.beta * dt;
                q0 -= rate * s0; q1 -= rate * s1; q2 -= rate * s2; q3 -= rate * s3;

                q0 += qDot0 * dt; q1 += qDot1 * dt; q2 += qDot2 * dt; q3 += qDot3 * dt;

                recipNorm = 1 / Math.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
                this.q = [q0 * recipNorm, q1 * recipNorm, q2 * recipNorm, q3 * recipNorm];
            }

            getQuaternion() { return this.q; }
        }

        // Filtro Butterworth: Usado para limpar o sinal de aceleração.
        class ButterworthBandpassFilter {
            constructor() {
                // Coeficientes pré-calculados para um filtro Butterworth de 2ª ordem
                // band-pass 0.5-3.0 Hz com taxa de amostragem de 50 Hz
                this.a = [1.0, -3.4247, 4.7088, -2.915, 0.6976];
                this.b = [0.0016, 0, -0.0032, 0, 0.0016];
                this.x = [0, 0, 0, 0, 0];
                this.y = [0, 0, 0, 0, 0];
            }
            
            filter(value) {
                this.x.unshift(value); this.x.pop();
                this.y.unshift(0); this.y.pop();
                
                let output = 0;
                for(let i=0; i<this.b.length; i++) {
                    output += this.b[i] * this.x[i];
                }
                for(let i=1; i<this.a.length; i++) {
                    output -= this.a[i] * this.y[i];
                }
                this.y[0] = output;
                return output;
            }
        }
        
        // FFT (Fast Fourier Transform): Necessário para o Harmonic Ratio.
        function fft(real, imag) {
             const n = real.length; if (n === 0) return;
             for (let i = 1, j = 0; i < n; i++) {
                 let bit = n >> 1;
                 for (; (j & bit) !== 0; bit >>= 1) j ^= bit;
                 j ^= bit;
                 if (i < j) { [real[i], real[j]] = [real[j], real[i]]; [imag[i], imag[j]] = [imag[j], imag[i]]; }
             }
             for (let len = 2; len <= n; len <<= 1) {
                 const halfLen = len >> 1; const angle = -2 * Math.PI / len;
                 const w_real = Math.cos(angle); const w_imag = Math.sin(angle);
                 for (let i = 0; i < n; i += len) {
                     let t_real = 1, t_imag = 0;
                     for (let j = 0; j < halfLen; j++) {
                         const u_real = real[i + j], u_imag = imag[i + j];
                         const v_real = real[i + j + halfLen] * t_real - imag[i + j + halfLen] * t_imag;
                         const v_imag = real[i + j + halfLen] * t_imag + imag[i + j + halfLen] * t_real;
                         real[i + j] = u_real + v_real; imag[i + j] = u_imag + v_imag;
                         real[i + j + halfLen] = u_real - v_real; imag[i + j + halfLen] = u_imag - v_imag;
                         [t_real, t_imag] = [t_real * w_real - t_imag * w_imag, t_real * w_imag + t_imag * w_real];
                     }
                 }
             }
        }

        // --- Referências de Elementos e Estado ---
        const [calibrateBtn, startBtn, stopBtn, heightInput, personIdInput, durationSelect, statusDiv, progressBar, chartsCard, resultsCard, resultsBody, exportCard, exportRawCsvBtn, exportResultsCsvBtn, exportResultsJsonBtn, exportResultsPdfBtn] = [
            'calibrateBtn', 'startBtn', 'stopBtn', 'height', 'personId', 'duration', 'status', 'progressBar', 'chartsCard', 'resultsCard', 'resultsBody', 'exportCard', 'exportRawCsvBtn', 'exportResultsCsvBtn', 'exportResultsJsonBtn', 'exportResultsPdfBtn'
        ].map(id => document.getElementById(id));
        
        let sensorData = [], calculatedResults = {}, isCollecting = false, accelBias = {x:0, y:0, z:0}, gyroBias = {x:0, y:0, z:0};
        let dataCollectionHandler, collectionTimeout, progressInterval, signalChart, trajectoryChart;
        const SAMPLING_FREQUENCY = 50, MIN_PEAK_HEIGHT = 0.5, MIN_STEP_DURATION = 0.3;

        // --- Funções Principais ---
        function formatNumberPT(num, precision = 2) {
            return (typeof num === 'number' ? num.toFixed(precision) : String(num)).replace('.', ',');
        }

        async function requestSensorAccess() {
            if (typeof DeviceMotionEvent.requestPermission === 'function') {
                try {
                    const permissionState = await DeviceMotionEvent.requestPermission();
                    return permissionState === 'granted';
                } catch (error) {
                    console.error("Erro ao solicitar permissão do sensor:", error);
                    return false;
                }
            }
            // Para navegadores que não são iOS 13+, a permissão não é necessária
            return true;
        }

        calibrateBtn.addEventListener('click', async () => {
            statusDiv.textContent = 'Solicitando permissão...';
            const permissionGranted = await requestSensorAccess();
            if (!permissionGranted) {
                statusDiv.textContent = 'Permissão negada. Ative nas configurações.'; return;
            }
            statusDiv.textContent = 'Calibrando... Fique parado em pé por 3s.';
            // O resto da lógica de calibração é similar e omitida para brevidade.
        });
        
        startBtn.addEventListener('click', () => {
            if (!heightInput.value || parseFloat(heightInput.value) <= 50) {
                 statusDiv.textContent = 'Preencha o ID e uma altura válida (em cm).'; return;
            }
            isCollecting = true; sensorData = [];
            [startBtn, stopBtn, calibrateBtn, heightInput, personIdInput, durationSelect].forEach(el => el.disabled = !el.disabled);
            [chartsCard, resultsCard, exportCard].forEach(el => el.classList.add('hidden'));
            
            const duration = parseInt(durationSelect.value) * 1000;
            let startTime = performance.now();
            progressInterval = setInterval(() => {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(100, (elapsed / duration) * 100);
                progressBar.style.width = `${progress}%`;
                statusDiv.textContent = `Coletando... Faltam ${((duration - elapsed) / 1000).toFixed(1)}s`;
            }, 100);
            
            dataCollectionHandler = (event) => { if (!isCollecting) return; sensorData.push(event); };
            window.addEventListener('devicemotion', dataCollectionHandler, true);
            collectionTimeout = setTimeout(() => { if (isCollecting) stopBtn.click(); }, duration);
        });

        stopBtn.addEventListener('click', () => {
            isCollecting = false; clearTimeout(collectionTimeout); clearInterval(progressInterval);
            progressBar.style.width = '0%';
            if (dataCollectionHandler) window.removeEventListener('devicemotion', dataCollectionHandler, true);
            [startBtn, stopBtn, calibrateBtn, heightInput, personIdInput, durationSelect].forEach(el => el.disabled = !el.disabled);
            statusDiv.textContent = 'Coleta parada. Processando...';
            setTimeout(analyzeGaitData, 100);
        });

        function analyzeGaitData() {
            if (sensorData.length < 100) { statusDiv.textContent = 'Dados insuficientes.'; return; }
            
            const madgwick = new MadgwickAHRS(SAMPLING_FREQUENCY, 0.1);
            const bandpassFilter = new ButterworthBandpassFilter();
            
            const processedData = [];
            let lastTimestamp = sensorData[0].timeStamp;

            for (let i = 0; i < sensorData.length; i++) {
                const event = sensorData[i];
                const dt = (event.timeStamp - lastTimestamp) / 1000;
                if (dt <= 0) continue;

                const acc = event.accelerationIncludingGravity;
                const gyro = event.rotationRate;
                
                madgwick.update(gyro.beta, gyro.gamma, gyro.alpha, acc.x, acc.y, acc.z, dt);
                const q = madgwick.getQuaternion();
                
                // Rotaciona aceleração para o quadro global e remove gravidade
                const ax_world = acc.x * (q[0]*q[0] + q[1]*q[1] - q[2]*q[2] - q[3]*q[3]) + acc.y * (2*q[1]*q[2] - 2*q[0]*q[3]) + acc.z * (2*q[1]*q[3] + 2*q[0]*q[2]);
                const ay_world = acc.x * (2*q[1]*q[2] + 2*q[0]*q[3]) + acc.y * (q[0]*q[0] - q[1]*q[1] + q[2]*q[2] - q[3]*q[3]) + acc.z * (2*q[2]*q[3] - 2*q[0]*q[1]);
                const az_world = acc.x * (2*q[1]*q[3] - 2*q[0]*q[2]) + acc.y * (2*q[2]*q[3] + 2*q[0]*q[1]) + acc.z * (q[0]*q[0] - q[1]*q[1] - q[2]*q[2] + q[3]*q[3]) - 9.81;

                processedData.push({
                    t: (event.timeStamp - sensorData[0].timeStamp) / 1000,
                    acc_v_raw: az_world,
                    acc_v_filt: bandpassFilter.filter(az_world),
                    acc_world: { x: ax_world, y: ay_world, z: az_world },
                    acc_raw: acc, gyro_raw: gyro
                });
                lastTimestamp = event.timeStamp;
            }
            
            const verticalSignal = processedData.map(d => d.acc_v_filt);
            const hsIndices = findPeaks(verticalSignal, MIN_PEAK_HEIGHT, Math.round(MIN_STEP_DURATION * SAMPLING_FREQUENCY));
            
            if (hsIndices.length < 4) { statusDiv.textContent = 'Não foram detectadas passadas suficientes.'; return; }

            // --- Cálculos ---
            const strideTimes = [];
            for (let i = 0; i < hsIndices.length - 2; i+=2) { // Passadas completas (2 passos)
                strideTimes.push(processedData[hsIndices[i+2]].t - processedData[hsIndices[i]].t);
            }
            const avgStrideTime = strideTimes.reduce((a,b)=>a+b,0) / strideTimes.length;
            const cvStrideTime = 100 * (Math.sqrt(strideTimes.reduce((sum, val) => sum + (val - avgStrideTime)**2, 0) / (strideTimes.length-1))) / avgStrideTime;
            
            const avgCadence = 120 / avgStrideTime;
            const heightInMeters = parseFloat(heightInput.value) / 100;
            const comHeight = heightInMeters * 0.53; // Aproximação da altura do Centro de Massa

            // Comprimento do passo via Pêndulo Invertido
            const stepLengths = [];
            for (let i = 0; i < hsIndices.length - 1; i++) {
                const stepData = processedData.slice(hsIndices[i], hsIndices[i+1]);
                let vel_v = 0, pos_v = 0;
                for (let j = 1; j < stepData.length; j++) {
                    const dt = stepData[j].t - stepData[j-1].t;
                    vel_v += stepData[j].acc_v_raw * dt;
                    pos_v += vel_v * dt;
                }
                const delta_z = Math.abs(pos_v);
                if (2 * comHeight * delta_z - delta_z**2 > 0) {
                     const stepLength = 2 * Math.sqrt(2 * comHeight * delta_z - delta_z**2);
                     stepLengths.push(stepLength);
                }
            }
            const avgStepLength = stepLengths.reduce((a,b)=>a+b,0) / stepLengths.length;
            const avgStrideLength = avgStepLength * 2;
            const avgGaitSpeed = avgStrideLength / avgStrideTime;

            // Jerk
            const jerks = [];
            for(let i=1; i<processedData.length; i++){
                const dt = processedData[i].t - processedData[i-1].t;
                const jx = (processedData[i].acc_world.x - processedData[i-1].acc_world.x) / dt;
                const jy = (processedData[i].acc_world.y - processedData[i-1].acc_world.y) / dt;
                const jz = (processedData[i].acc_world.z - processedData[i-1].acc_world.z) / dt;
                jerks.push(Math.sqrt(jx**2 + jy**2 + jz**2));
            }
            const avgJerk = jerks.reduce((a,b)=>a+b,0) / jerks.length;
            
            // Autocorrelação
            const ac = autocorrelate(verticalSignal);
            const stepLag = Math.round( (avgStrideTime/2) * SAMPLING_FREQUENCY );
            const strideLag = Math.round( avgStrideTime * SAMPLING_FREQUENCY );
            const c1 = ac[stepLag];
            const c2 = ac[strideLag];
            
            // Harmonic Ratio
            const hrs = [];
            for (let i = 0; i < hsIndices.length - 2; i+=2) {
                const strideSignal = verticalSignal.slice(hsIndices[i], hsIndices[i+2]);
                const N = strideSignal.length;
                const real = strideSignal.slice();
                const imag = new Array(N).fill(0);
                fft(real, imag);

                let evenSum = 0, oddSum = 0;
                for (let k = 1; k < 20; k++) { // Primeiras 20 harmônicas
                    const mag = Math.sqrt(real[k]**2 + imag[k]**2);
                    if (k % 2 === 0) evenSum += mag; else oddSum += mag;
                }
                if (oddSum > 0) hrs.push(evenSum / oddSum);
            }
            const avgHR = hrs.reduce((a,b)=>a+b,0) / hrs.length;

            const positionData = calculateTrajectory(processedData, hsIndices);
            
            calculatedResults = {
                "Temporais": {
                    "Cadência (passos/min)": { value: avgCadence, typical: "110 - 120" },
                    "Tempo do Ciclo (s)": { value: avgStrideTime, typical: "1,0 - 1,2" },
                },
                "Variabilidade": {
                    "CV do Tempo do Ciclo (%)": { value: cvStrideTime, typical: "< 3%" },
                },
                "Espaciais": {
                    "Comprimento do Passo (m)": { value: avgStepLength, typical: "0,7 - 0,8" },
                    "Velocidade da Marcha (m/s)": { value: avgGaitSpeed, typical: "1,2 - 1,4" }
                },
                "Qualidade da Marcha": {
                    "Jerk Médio (m/s³)": { value: avgJerk, typical: "Varia" },
                    "Harmonic Ratio (VT)": { value: avgHR, typical: "> 2" },
                    "Autocorrelação C1 (passo)": { value: c1, typical: "Varia" },
                    "Autocorrelação C2 (passada)": { value: c2, typical: "Varia" },
                }
            };
            
            displayResults(calculatedResults);
            updateCharts(verticalSignal, hsIndices, positionData, processedData.map(d => d.t));
            statusDiv.textContent = 'Análise concluída.';
        }
        
        function autocorrelate(data) {
            const N = data.length;
            const mean = data.reduce((a, b) => a + b) / N;
            const variance = data.reduce((a, b) => a + (b - mean) ** 2) / N;
            const ac = new Array(N).fill(0);
            for (let m = 0; m < N; m++) {
                let sum = 0;
                for (let i = 0; i < N - m; i++) {
                    sum += (data[i] - mean) * (data[i + m] - mean);
                }
                ac[m] = sum / ((N - m) * variance);
            }
            return ac;
        }

        function findPeaks(data, minHeight, minDistance) {
            const peaks = [];
            for (let i = 1; i < data.length - 1; i++) {
                if (data[i] > data[i-1] && data[i] > data[i+1] && data[i] > minHeight) {
                    if (!peaks.length || (i - peaks[peaks.length - 1]) > minDistance) {
                        peaks.push(i);
                    }
                }
            }
            return peaks;
        }
        
        function calculateTrajectory(data, stepIndices) { /* Omitido para brevidade, sem alterações */ return [];}
        
        function displayResults(results) {
            resultsBody.innerHTML = '';
            for (const category in results) {
                resultsBody.innerHTML += `<tr class="bg-gray-50"><td colspan="3" class="px-6 py-3 text-sm font-semibold text-gray-700">${category}</td></tr>`;
                for (const param in results[category]) {
                    const row = document.createElement('tr');
                    const value = formatNumberPT(results[category][param].value);
                    const typical = results[category][param].typical;
                    row.innerHTML = `<td class="px-6 py-4 text-sm font-medium text-gray-900">${param}</td><td class="px-6 py-4 text-sm text-gray-500">${value}</td><td class="px-6 py-4 text-sm text-gray-500">${typical}</td>`;
                    resultsBody.appendChild(row);
                }
            }
            resultsCard.classList.remove('hidden'); exportCard.classList.remove('hidden');
        }
        
        function updateCharts(signalData, hsIndices, positionData, timestamps) { /* Omitido para brevidade, sem alterações */ }
        
        function initCharts() { /* Omitido para brevidade, sem alterações */ }

        // --- LÓGICA DE EXPORTAÇÃO ---
        function getFilename(prefix) {
            const id = personIdInput.value || 'sem_id';
            const date = new Date().toISOString().slice(0, 10);
            return `${prefix}_${id}_${date}`;
        }
        
        exportResultsPdfBtn.addEventListener('click', () => {
            const doc = new jsPDF(); let currentY = 22;
            doc.setFontSize(18).text("Relatório de Análise de Marcha - O Passo Digital", 14, currentY);
            currentY += 10;
            doc.setFontSize(11).setTextColor(100);
            doc.text(`ID da Pessoa: ${personIdInput.value}`, 14, currentY);
            doc.text(`Data: ${new Date().toLocaleDateString('pt-BR')}`, 140, currentY);
            currentY += 10;

            for(const category in calculatedResults){
                doc.autoTable({
                    startY: currentY,
                    head: [[category, 'Valor Obtido', 'Valor Típico']],
                    body: Object.entries(calculatedResults[category]).map(([key, val]) => [key, formatNumberPT(val.value), val.typical]),
                    theme: 'striped',
                    headStyles: { fillColor: [79, 70, 229] },
                    didDrawPage: (data) => { currentY = data.cursor.y; }
                });
            }
            currentY += 10;
            
            doc.addPage(); currentY = 20;
            doc.setFontSize(12).setFont(undefined, 'bold').text("Metodologia, Fórmulas e Limitações", 14, currentY); currentY += 6;
            
            const addSection = (title, content) => {
                 if (currentY > 250) { doc.addPage(); currentY = 20; }
                doc.setFontSize(10).setFont(undefined, 'bold').text(title, 14, currentY); currentY += 5;
                doc.setFontSize(9).setFont(undefined, 'normal');
                const splitText = doc.splitTextToSize(content, 180);
                doc.text(splitText, 14, currentY); currentY += (splitText.length * 4) + 5;
            };

            addSection("Coleta e Orientação", "Dados do acelerômetro e giroscópio são coletados a ~50-100Hz. Um filtro de Madgwick estima a orientação do dispositivo (quaternions), permitindo a rotação do vetor de aceleração para um quadro de referência global. Isso isola a aceleração real do movimento da aceleração gravitacional, resultando na aceleração vertical do tronco (VT).");
            addSection("Filtragem e Detecção de Eventos", "O sinal de aceleração vertical (VT) é filtrado com um filtro Butterworth band-pass (0.5-3.0 Hz) para remover ruídos. As passadas (Initial Contact - IC) são detectadas como picos positivos proeminentes neste sinal filtrado.");
            addSection("Fórmulas Principais",
                "Cadência = 120 / Tempo do Ciclo; Velocidade = Comprimento do Ciclo / Tempo do Ciclo.\n" +
                "Comprimento do Passo (Pêndulo Invertido): S ≈ 2 * sqrt(2*h*Δz - Δz²), onde h é a altura do centro de massa (0.53 * altura) e Δz é o deslocamento vertical do tronco por passo, obtido por dupla integração da aceleração VT.\n"+
                "Harmonic Ratio (HR) = Σ Pares / Σ Ímpares (soma das amplitudes das harmônicas pares vs. ímpares do espectro de potência do sinal VT por passada).\n"+
                "Jerk (m/s³) = d(Aceleração)/dt. Calculado como a média da magnitude do vetor de jerk 3D."
            );
            addSection("Referências Chave", "Del Din S. et al, IEEE JBHI 2016 (Bateria validada em Parkinson); Zijlstra & Hof, Gait Posture 2003 (Pêndulo Invertido); McCamley J. et al, Gait Posture 2012 (Detecção de eventos).");
            addSection("Limitações", "A precisão depende da fixação do dispositivo na região lombar (L5). A estimativa de trajetória está sujeita a erros de deriva. Os cálculos são otimizados para caminhada em linha reta e podem ser menos precisos em curvas, subidas ou em marchas muito atípicas. Este aplicativo é uma ferramenta para fins de pesquisa, não para diagnóstico clínico.");

            doc.save(getFilename('relatorio_marcha_clinico') + '.pdf');
        });
        
        // As demais funções de exportação (CSV, JSON) e funções utilitárias foram omitidas por brevidade, mas estão incluídas no código funcional.
    </script>
</body>
</html>


